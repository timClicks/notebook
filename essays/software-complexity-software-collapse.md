```yaml
title:  tbd
date:   5 Mar 2021
status: unpublished draft
author: Tim McNamara <tim@mcnamara.nz>
```

# Avoiding software collapse

> Summary
>
> The overall thesis is that programming languages, and perhaps all software, tend to increase in 
> complexity until they hit some limit where they collapse under their own weight. The community, 
> once thriving, migrates to alternatives.
>
> A secondary theme is that software is surprisingly short-lived. We think of software as being 
> able to be presered forever, because digital assets are able to be flawlessly copied from one 
> storage medium to another over time. However, it's proven to be the case that paper and 
> traditional archives tend to be preserved far longer.

John Outerhout bellieves that the only remedy to this is consistently spending time to polish 
the code. That is, spend time investing on improving the software's qualty before the software 
is so bad that you need to stop everything to fix it.

Another one of his beliefs is that people shouldn't worry about their current position on 
the `y` axis (where `y` is "success"), but their gradient. A sharper gradient will get there.

Large software projects develop strata, largely influenced by changes to the people working on 
the project. If some code survives more than 5 years in production, there is a good chance that
the person who wrote it will have changed employers or changed roles. Either way, they are no 
longer making technical decisions. Some people prefer unit tests, others prefer integration 
tests. Some people prefer using interfaces, others prefer the security of passing around concrete
types.

Fashion choices like this are more pronounced when the softare industry embraces a paradigm that
your language is unsuited for. 

The situation changes somewhat with an established project. It's possible that you're in a 
situation where the software package you're supporting is now entrenched in a business. 
Migration is considered too difficult or risky.

---

## Scattered thoughts

[] performance is bounded, success is unbounded


Idea: software businesses are businesses that are happy to swap out the implementation. Non-software
businesse that use software to get their job done cannot. They're happy with the terrible old
thing. And even if they're unhappy, they don't have a strong incentive to move foward. These are 
the same people who manage entire businesses from within Excel.

project's leaders. 

The older layers 
tend to remain, however. T
